use std::path::PathBuf;

use clap::{Parser, Subcommand};

use cranelift_filetests::zkasm_codegen::{generate_zkasm, ZkasmSettings};

/// A CLI to analyze zkasm generated by cranelift.
#[derive(Parser)]
#[command(version, about, long_about = None)]
#[command(propagate_version = true)]
struct Cli {
    #[command(subcommand)]
    command: Command,
}

#[derive(Subcommand)]
enum Command {
    /// Generate zkasm that calls zkevm-proverjs helpers to trace executed instructions.
    #[command[arg_required_else_help = true]]
    InstrumentInst {
        /// Path to the input WAT file.
        wat_path: PathBuf,
        /// Path to the file where generated zkasm is written.
        out_path: PathBuf,
    },
}

fn main() -> anyhow::Result<()> {
    let cli = Cli::parse();

    match &cli.command {
        Command::InstrumentInst { wat_path, out_path } => {
            instrument_inst(wat_path, out_path)?;
            println!("wrote instrumented zkASM to {}", out_path.display());
        }
    }

    Ok(())
}

fn instrument_inst(wat_path: &PathBuf, out_path: &PathBuf) -> anyhow::Result<()> {
    let wasm_module = wat::parse_file(wat_path)?;
    let zkasm_settings = ZkasmSettings {
        emit_profiling_info: true,
    };
    let zkasm = generate_zkasm(&zkasm_settings, &wasm_module);
    std::fs::write(out_path, zkasm.as_bytes())?;
    Ok(())
}
