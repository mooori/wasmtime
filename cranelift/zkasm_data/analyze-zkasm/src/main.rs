use std::path::PathBuf;

use clap::{Parser, Subcommand};

use cranelift_filetests::zkasm_codegen::{generate_zkasm, ZkasmSettings};

/// A CLI to analyze zkasm generated by cranelift.
#[derive(Parser)]
#[command(version, about, long_about = None)]
#[command(propagate_version = true)]
struct Cli {
    #[command(subcommand)]
    command: Command,
}

#[derive(Subcommand)]
enum Command {
    /// Generate zkasm that calls zkevm-proverjs helpers to trace executed instructions.
    #[command[arg_required_else_help = true]]
    InstrumentInst {
        /// Path to the input WAT file.
        wat_path: PathBuf,
        /// Path to the file where generated zkasm is written.
        out_path: PathBuf,
    },
}

fn main() -> anyhow::Result<()> {
    let cli = Cli::parse();

    match &cli.command {
        Command::InstrumentInst { wat_path, out_path } => {
            let zkasm = instrument_inst(wat_path)?;
            std::fs::write(out_path, zkasm.as_bytes())?;
            println!("wrote instrumented zkASM to {}", out_path.display());
        }
    }

    Ok(())
}

fn instrument_inst(wat_path: &PathBuf) -> anyhow::Result<String> {
    let wasm_module = wat::parse_file(wat_path)?;
    let zkasm_settings = ZkasmSettings {
        emit_profiling_info: true,
    };
    Ok(generate_zkasm(&zkasm_settings, &wasm_module))
}

#[cfg(test)]
mod tests {
    use std::path::PathBuf;

    use super::instrument_inst;

    #[test]
    fn test_instrument_inst() -> anyhow::Result<()> {
        let zkasm = instrument_inst(&PathBuf::from("./testfiles/simple.wat"))?;
        let expected_zkasm =
            std::fs::read_to_string("./testfiles/simple_instrumented.zkasm").unwrap();
        assert_eq!(zkasm, expected_zkasm);
        Ok(())
    }
}
